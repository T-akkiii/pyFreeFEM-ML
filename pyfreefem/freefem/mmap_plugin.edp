// PyFreeFEM共有メモリモジュール
// 
// このスクリプトは、FreeFEM側で共有メモリを介してPythonとデータ交換するための
// 関数を提供します。

// 必要なプラグインを読み込み
load "mmap-semaphore"  // 共有メモリプラグイン

// ========== 共有メモリ関係の関数 ==========

// キーから共有メモリハンドルを取得する関数
func int getShmKey()
{
  string key_str = getenv("PYFREEFEM_SHM_KEY");
  if (key_str == "")
  {
    cout << "環境変数PYFREEFEM_SHM_KEYが設定されていません" << endl;
    return 0;
  }
  
  return atoi(key_str);
}

// 共有メモリハンドルを作成
func mmap getPyFreeFEMShm()
{
  int key = getShmKey();
  if (key <= 0)
  {
    cout << "無効な共有メモリキーです: " << key << endl;
    exit(1);
  }
  
  // 環境変数から共有メモリサイズを取得
  string size_str = getenv("PYFREEFEM_SHM_SIZE");
  int size = (size_str != "") ? atoi(size_str) : 1024*1024;
  
  // すでに作成された共有メモリにアタッチ
  mmap shm = mmap_create(key, size);
  
  return shm;
}

// メタデータを読み込む関数
func string readMetadata(mmap& shm)
{
  // メタデータ領域のサイズ
  int metadata_size = 4096;
  
  // メタデータを読み込み
  string metadata = "";
  for (int i = 0; i < metadata_size; i++)
  {
    char c = shm[i];
    if (c == 0) break;  // NULL文字で終了
    metadata = metadata + c;
  }
  
  return metadata;
}

// キーに対応するデータ位置情報を取得する関数
func int[int] getKeyOffset(mmap& shm, string key)
{
  // メタデータを読み込み
  string metadata_json = readMetadata(shm);
  
  // JSONパースの代わりに必要な情報を文字列処理で抽出
  // ※FreeFEMにはJSON処理機能がないため、簡易的な文字列処理を行う
  
  // キーパターンを構築
  string pattern = '"' + key + '":{"offset":';
  
  // パターンの位置を検索
  int pos = metadata_json.find(pattern);
  if (pos < 0)
  {
    cout << "キー '" << key << "' が見つかりません" << endl;
    int[int] empty(3);
    empty[0] = -1;
    empty[1] = 0;
    empty[2] = 0;
    return empty;
  }
  
  // offset値を抽出
  int offset_start = pos + pattern.length();
  int offset_end = metadata_json.find(",", offset_start);
  string offset_str = metadata_json.substr(offset_start, offset_end - offset_start);
  int offset = atoi(offset_str);
  
  // size値を抽出
  string size_pattern = '"size":';
  int size_pos = metadata_json.find(size_pattern, offset_end);
  int size_start = size_pos + size_pattern.length();
  int size_end = metadata_json.find(",", size_start);
  string size_str = metadata_json.substr(size_start, size_end - size_start);
  int size = atoi(size_str);
  
  // type値を抽出
  string type_pattern = '"type":"';
  int type_pos = metadata_json.find(type_pattern, size_end);
  int type_start = type_pos + type_pattern.length();
  int type_end = metadata_json.find('"', type_start);
  string type_str = metadata_json.substr(type_start, type_end - type_start);
  
  // 型をコードに変換
  int type_code = 0;
  if (type_str == "INT") type_code = 1;
  else if (type_str == "DOUBLE") type_code = 2;
  else if (type_str == "STRING") type_code = 3;
  else if (type_str == "ARRAY") type_code = 4;
  
  // 結果を配列で返す [offset, size, type]
  int[int] result(3);
  result[0] = offset;
  result[1] = size;
  result[2] = type_code;
  
  return result;
}

// ========== データの読み込み関数 ==========

// 整数値を読み込む関数
func int readInt(mmap& shm, string key)
{
  // キーに対応するデータ位置情報を取得
  int[int] info = getKeyOffset(shm, key);
  int offset = info[0];
  int size = info[1];
  int type = info[2];
  
  if (offset < 0)
  {
    cout << "キー '" << key << "' に対応するデータが見つかりません" << endl;
    return 0;
  }
  
  if (type != 1)
  {
    cout << "キー '" << key << "' のデータは整数型ではありません" << endl;
    return 0;
  }
  
  // バイト配列から整数値を復元
  int value = 0;
  for (int i = 0; i < 4; i++)
  {
    int byte_val = (int)shm[offset + i];
    value = value | (byte_val << (8 * i));
  }
  
  return value;
}

// 浮動小数点値を読み込む関数
func real readDouble(mmap& shm, string key)
{
  // キーに対応するデータ位置情報を取得
  int[int] info = getKeyOffset(shm, key);
  int offset = info[0];
  int size = info[1];
  int type = info[2];
  
  if (offset < 0)
  {
    cout << "キー '" << key << "' に対応するデータが見つかりません" << endl;
    return 0.0;
  }
  
  if (type != 2)
  {
    cout << "キー '" << key << "' のデータは浮動小数点型ではありません" << endl;
    return 0.0;
  }
  
  // バイト配列から浮動小数点値を復元
  // 注意: これは正確な変換ではなく、簡易的な実装
  real value = 0.0;
  
  // 代わりにキーの個別要素を直接アクセス
  // これはPython側で書き込むときに各要素を個別に書き込むため
  value = 0.0;
  for (int i = 0; i < 8; i++)
  {
    int byte_val = (int)shm[offset + i];
    value = value + (byte_val / 256.0) * (2^(8*i));
  }
  
  return value;
}

// 文字列を読み込む関数
func string readString(mmap& shm, string key)
{
  // キーに対応するデータ位置情報を取得
  int[int] info = getKeyOffset(shm, key);
  int offset = info[0];
  int size = info[1];
  int type = info[2];
  
  if (offset < 0)
  {
    cout << "キー '" << key << "' に対応するデータが見つかりません" << endl;
    return "";
  }
  
  if (type != 3)
  {
    cout << "キー '" << key << "' のデータは文字列型ではありません" << endl;
    return "";
  }
  
  // 文字列の長さを取得
  int length = 0;
  for (int i = 0; i < 4; i++)
  {
    int byte_val = (int)shm[offset + i];
    length = length | (byte_val << (8 * i));
  }
  
  // 文字列を構築
  string value = "";
  for (int i = 0; i < length; i++)
  {
    char c = shm[offset + 4 + i];
    value = value + c;
  }
  
  return value;
}

// 配列を読み込む関数
func real[int] readArray(mmap& shm, string key)
{
  // キーに対応するデータ位置情報を取得
  int[int] info = getKeyOffset(shm, key);
  int offset = info[0];
  int size = info[1];
  int type = info[2];
  
  if (offset < 0)
  {
    cout << "キー '" << key << "' に対応するデータが見つかりません" << endl;
    real[int] empty(1);
    empty[0] = 0.0;
    return empty;
  }
  
  if (type != 4)
  {
    cout << "キー '" << key << "' のデータは配列型ではありません" << endl;
    real[int] empty(1);
    empty[0] = 0.0;
    return empty;
  }
  
  // 配列の長さを取得
  int length = 0;
  for (int i = 0; i < 4; i++)
  {
    int byte_val = (int)shm[offset + i];
    length = length | (byte_val << (8 * i));
  }
  
  // 配列を作成
  real[int] array(length);
  
  // 代わりに個別の要素アクセスを使用
  // (Python側で配列の各要素を個別に書き込むため)
  string size_key = key + "_size";
  int array_size = readInt(shm, size_key);
  
  for (int i = 0; i < array_size; i++)
  {
    string element_key = key + "_" + i;
    array[i] = readDouble(shm, element_key);
  }
  
  return array;
}

// ========== データの書き込み関数 ==========

// 整数値を書き込む関数
func void writeInt(mmap& shm, string key, int value, int offset)
{
  // バイト配列に整数値を変換
  for (int i = 0; i < 4; i++)
  {
    int byte_val = (value >> (8 * i)) & 0xFF;
    shm[offset + i] = byte_val;
  }
}

// 浮動小数点値を書き込む関数
func void writeDouble(mmap& shm, string key, real value, int offset)
{
  // 注意: これは正確な変換ではなく、簡易的な実装
  // 実際のアプリケーションでは、バイナリ変換のためにCプラグインを使用する方が良い
  
  // バイト配列に浮動小数点値を変換
  int bits = 0;
  for (int i = 0; i < 8; i++)
  {
    int byte_val = int(value * 256.0) & 0xFF;
    shm[offset + i] = byte_val;
    value = value / 256.0;
  }
}

// 文字列を書き込む関数
func void writeString(mmap& shm, string key, string value, int offset)
{
  // 文字列の長さを書き込む
  int length = value.length;
  writeInt(shm, key, length, offset);
  
  // 文字列を書き込む
  for (int i = 0; i < length; i++)
  {
    shm[offset + 4 + i] = value(i);
  }
}

// 配列を書き込む関数
func void writeArray(mmap& shm, string key, real[int]& array, int offset)
{
  // 配列の長さを書き込む
  int length = array.n;
  writeInt(shm, key, length, offset);
  
  // 配列データを書き込む
  int data_offset = offset + 4;
  for (int i = 0; i < length; i++)
  {
    writeDouble(shm, key, array[i], data_offset + i * 8);
  }
} 